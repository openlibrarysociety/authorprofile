#!/usr/bin/perl

use strict;
use warnings;

sub vert_go_further_from {

  my $init_auth=shift;
  my $i_aun=shift;
  # $vema_values is deprecated - I have forgotten why this was here, but it should be removed.
  my $vema_values=shift;
  my $r=shift;
  my $dist=shift;
# This was generated by &find_aunexes_for_aun.
  my $n_aun=shift;
  my $neighbors=shift;
  my $poma=shift;
  my $verbosity=$VERBOSE;
  my $dry_run=$DEBUG;

  my $w=0;
  my $i=1;

  my $n_i=scalar(keys %{$neighbors->{'w'}});


  die "vert_go_further_from: FATAL ERROR: \$n_aun not passed.\n" if not $n_aun;


  my $vema_key=normalize_name($n_aun);
  my $vema=&vema_db_retrieve($vema_key, $g_collec_vema);



  if(not $r or not defined($r->{'p'}->{$dist}->{$n_aun})) {
    #This is still needed to construct the vema path...
    $r->{'p'}->{$dist}->{$n_aun}=$i_aun;
  }
  
  # The weight for the neighbors structure was not stored as a symmetric weight value, but instead, as simply the summation of the total amount of collaborating authors for each paper collaborated upon by the authors to whom the aunexes being compared belong.  I am not sure what my reasoning behind this was at the time, but it may be unnecessary.

  $w=$neighbors->{'w'}->{$n_aun};

  $w > 0 ? $r->{'w'}->{$i_aun}->{$n_aun}=$w : die "FATAL ERROR: Edge weight for $i_aun and $n_aun could not be found.\n", Dumper $neighbors;

  # switch...case n...break



  # If a vema path has already been stored into the database...
  if($vema) {

    print "\nDEBUG: Path from $n_aun to $init_auth at a distance of $dist is longer than $vema->{'p'} at a distance of $vema->{'d'}\n\n" if $vema->{'d'} < $dist;

    # ...first check to see if the stored path is of a greater length that the path just generated for the aunex being explored...
    if($vema->{'d'} > $dist) {
        
      print "vert_go_further_from: A shorter path has been found for $n_aun from $i_aun.\n" if $VERBOSE;
      # ...and store the newly calculated path if it is indeed shorter.
      &store_vema_values($n_aun, $init_auth, $dist, $r, $g_collec_vema) if not $dry_run;
    }
    # ...otherwise, if the length of the vema path is equal to the path that has been stored...
    elsif($vema->{'d'} == $dist) {

      # ...and if the weight is less than the stored path...
      if($vema->{'w'} > $r->{'w'}->{$i_aun}->{$n_aun}) {

        #...store the newly calculated vema path.
        print "A lighter path has been found for $n_aun from $i_aun.\n" if $VERBOSE;
        &store_vema_values($n_aun, $init_auth, $dist, $r, $g_collec_vema) if not $dry_run;        
      }
      # ...or, if the distance is the same but the weight of the newly calculated path is greater than the stored vema path, compare, then, use the poma for a conmparison...
      elsif($vema->{'e'} ne $init_auth and &compare_nodes_using_poma($vema->{'e'}, $init_auth, $poma) eq $init_auth) {

        # and if the preferred author is the initial node of this path, store the newly calculated vema path.
        print "A more direct path has been found for $n_aun from $i_aun.\n" if $VERBOSE;
        &store_vema_values($n_aun, $init_auth, $dist, $r, $g_collec_vema) if not $dry_run;
      }
      else {
        print "\nDEBUG: This path was already discovered.\n\n";
      }
    }
  }
  # ...and if the path hasn't been stored into the vema database at all, store the path.
  else {

    print "New path found for $n_aun from $i_aun.\n" if $VERBOSE;
    &store_vema_values($n_aun, $init_auth, $dist, $r, $g_collec_vema) if not $dry_run;
  }
  $i++;

  $vema=undef;
  return $r;
}
